Sahil Bambulkar 

July 29, 2021 

CS 280 Section 130 

Professor Jonathan Kapleau 


Besides a select few languages coerced by government mandate or corporate desire, most of the genealogy of programming languages has been driven by programmer preference. Languages that were preferred survived and continued to have widespread use, while less popular languages faded and today enjoy only middling use. As of 2021, three of the most popular programming languages in the world are Python, Java and C++ . With their widespread acceptance being any indication, all three languages are powerful and one is not strictly better than the others. Rather, the decision on which to use is based on its ability to handle the specific problem being tackled. For every problem each have their strengths and weaknesses which must be carefully considered when making the decision on which language to choose.  

For project four, that problem was implementing a complex number class. A complex number consists of a real part and an imaginary part. The real part is a real number while the imaginary part is a real number coefficient and imaginary unit constant 'i'. The imaginary unit constant is equivalent to the square root of negative one and evaluates to negative one when squared. The implementation required both coefficients of the real and imaginary number to be a double, or a floating-point number. The class was also required to be able to complete addition, subtraction, multiplication and true division operations both when leading and trailing the operator. Finally, it was required to be able to be printed in the correct 'a + bi' form.   

The Python implementation leveraged the language's flexibility which provided advantages and disadvantages. Python's succinct way of expressing default arguments meant that the complexC class constructor was able to be declared in only three lines of code. Compare that to the Java implementation's constructor statement which took more than double that number with seven lines of code. Additionally, Python's operator overloading was very capable with it being able to handle situations involving both leading and trailing the operator in just two functions. The issues began in the definitions of these operator overloading functions. Python is dynamically typed and strongly typed. For the complex number class implementation this meant that all formal arguments in the class constructor and all operator overloading functions had to be manually type checked. Type errors needed to be manually raised if the value does not fit the required types of int or double. This is an additional overhead to the class implementation that was not needed in the other statically typed languages of C++ and Java. While Python runs substantially slower than C++ and Java, this tradeoff normally comes with the benefit of requiring less lines code. Unfortunately, much of that advantage is lost as the manual type checking adds substantially more lines of code in comparison to the equivalent functions in the C++ and Java implementations. One benefit of it though, is that it allowed only two operator overloading functions while Java and C++ needed three. The same type checking allowed operations with either real or complex numbers to be differentiated and handled in the same place. 

The C++ implementation was done with a structure, or struct, rather than a class which differs only in that members of a struct are public by default and members of a class are private by default. While not required, the C++ implementation predeclares all the struct's functions. Another advantage, is that the constructor is only one line of code making Python's four lines of code constructor and Java's eight lines of code constructor look bloated in comparison. Similarly, almost all of its member definitions, from the constructor to each operator overloading function, are extremely succinct and very readable. C++ functions can be pass by reference, and while that is useful in some situations, for safety this complex struct implementation uses constant references so as not to change their values. Although one drawback of the implementation is the additional operation overloading function declaration needed, per operator, to account for either a real or a complex number. Another issue was in the handling of operations with a double and a complex number, with the complex trailing behind the operator. For example, in the subtraction operation 'd - (a + bi)' or division operation 'd / (a + bi)'. In C++, the formal arguments in the member function declarations are required to have the complex class or struct coming first. A consequence of this would be a failure to do an operation where the complex struct is trailing behind a double. Thus, these must be achieved through friend functions. This is not much of an inconvenience as they mirror Python and Java in functionality. 

While the C++ and Python implementations have powerful features that make them competitive, the Java implementation clearly falls behind. Java does not allow operator overloading at all which is a considerable loss to readability and flexibility of its complex class. Practically, this means that the class implementation is reliant on using function calls like '.add' , '.sub' , '.mul' and '.truediv' to do the arithmetic operations. The reason operator overloading is so powerful is that, when used sensibly, they seem more natural and add to readability. This is because the symbols are used elsewhere in the language and are common parlance to users in the language. Additionally, Java does not support default constructors and must simulate it through overloading a constructor. While this works, it subtracts from readability and requires considerably more lines of code with three constructors dedicated to it. The Java implementation has major drawbacks in its lack of operator overloading and lack of default constructors that makes it a distant third when comparing these three language implementations.  

All three languages possessed the ability to create this class but did so with different levels of readability and functionality. The Python and C++ implementations were both able to use operator overloading to add natural seeming arithmetic operation functionality. Java failing to do this was a major detriment. As for readability, the Python implementation's arguments need to have to be manually typed checked reduced from readability and ease of use of the function even if it reduced the number of functions. Meanwhile, the C++ implementation was able to have very succinct member functions, have default arguments in only one function definition, and have operator overloading. For these reasons, it is the superior language for this complex number implementation.  